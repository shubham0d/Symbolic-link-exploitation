#include "stdafx.h"
#include "FileOpLock.h"
#include "ReparsePoint.h"
#include <string>
#include <sddl.h>
#include <iostream>
#include <Windows.h>
#include "CommonUtils.h"
#include "ntimports.h"
#include "typed_buffer.h"
#include <chrono>
#include <thread>
#include <filesystem>
#include <iostream>
#include <fstream>  
#include "Shlwapi.h"
#include "shlobj.h"

#pragma comment( lib, "shlwapi.lib")

const char* targetfile;
char buffermsi[1024];

bool bSuccess = false;

wchar_t appDataFilePath[MAX_PATH];
wchar_t appDataDirPath[MAX_PATH];


std::wstring targetfw;
std::wstring targetfwDos;

std::wstring s2ws(const std::string& str)
{
	int size_needed = MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), NULL, 0);
	std::wstring wstrTo(size_needed, 0);
	MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &wstrTo[0], size_needed);
	return wstrTo;
}

bool DoesFileExist(LPCWSTR lpszFilename)
{
	DWORD fileAttr = GetFileAttributes(lpszFilename);
	DWORD lastErr = GetLastError();
	return ((fileAttr != INVALID_FILE_ATTRIBUTES)
		&& (lastErr != ERROR_FILE_NOT_FOUND));
}

bool dirExists(LPCWSTR dirName_in)
{
	DWORD ftyp = GetFileAttributes(dirName_in);
	if (ftyp == INVALID_FILE_ATTRIBUTES)
		return false;  //something is wrong with your path!

	if (ftyp & FILE_ATTRIBUTE_DIRECTORY)
		return true;   // this is a directory!

	return false;    // this is not a directory!
}

HANDLE CreateSymlink(HANDLE root, LPCWSTR linkname, LPCWSTR targetname)
{
	DEFINE_NTDLL(RtlInitUnicodeString);
	DEFINE_NTDLL(NtCreateSymbolicLinkObject);

	OBJECT_ATTRIBUTES objAttr;
	UNICODE_STRING name;
	UNICODE_STRING target;

	fRtlInitUnicodeString(&name, linkname);
	fRtlInitUnicodeString(&target, targetname);

	InitializeObjectAttributes(&objAttr, &name, OBJ_CASE_INSENSITIVE, root, nullptr);

	HANDLE hLink;

	NTSTATUS status = fNtCreateSymbolicLinkObject(&hLink,
		SYMBOLIC_LINK_ALL_ACCESS, &objAttr, &target);
	if (status == 0)
	{
		//DebugPrintf("Opened Link %ls -> %ls: %p\n", linkname, targetname, hLink);
		return hLink;
	}
	else
	{
		SetLastError(NtStatusToDosError(status));
		return nullptr;
	}
}


int main(int argc, const char* argv[])
{

	std::this_thread::sleep_for(std::chrono::milliseconds(9000000));
	return 0; 
}
